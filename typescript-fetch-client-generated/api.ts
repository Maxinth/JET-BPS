/// <reference path="./custom.d.ts" />
// tslint:disable
/**
 * MonieVoucher
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: 1.0.0
 * 
 *
 * NOTE: This file is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the file manually.
 */

import * as url from "url";
import * as isomorphicFetch from "isomorphic-fetch";
import { Configuration } from "./configuration";

const BASE_PATH = "http://localhost:8080".replace(/\/+$/, "");

/**
 *
 * @export
 */
export const COLLECTION_FORMATS = {
    csv: ",",
    ssv: " ",
    tsv: "\t",
    pipes: "|",
};

/**
 *
 * @export
 * @interface FetchAPI
 */
export interface FetchAPI {
    (url: string, init?: any): Promise<Response>;
}

/**
 *
 * @export
 * @interface FetchArgs
 */
export interface FetchArgs {
    url: string;
    options: any;
}

/**
 *
 * @export
 * @class BaseAPI
 */
export class BaseAPI {
    protected configuration: Configuration;

    constructor(configuration?: Configuration, protected basePath: string = BASE_PATH, protected fetch: FetchAPI = isomorphicFetch) {
        if (configuration) {
            this.configuration = configuration;
            this.basePath = configuration.basePath || this.basePath;
        }
    }
};

/**
 *
 * @export
 * @class RequiredError
 * @extends {Error}
 */
export class RequiredError extends Error {
    name: "RequiredError"
    constructor(public field: string, msg?: string) {
        super(msg);
    }
}

/**
 * 
 * @export
 * @interface Account
 */
export interface Account {
    /**
     * 
     * @type {string}
     * @memberof Account
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof Account
     */
    number?: string;
    /**
     * 
     * @type {string}
     * @memberof Account
     */
    type?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Account
     */
    active?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Account
     */
    createdDate?: string;
    /**
     * 
     * @type {number}
     * @memberof Account
     */
    amt?: number;
    /**
     * 
     * @type {number}
     * @memberof Account
     */
    balance?: number;
    /**
     * 
     * @type {string}
     * @memberof Account
     */
    currency?: string;
    /**
     * 
     * @type {number}
     * @memberof Account
     */
    fees?: number;
}
/**
 * 
 * @export
 * @interface Agency
 */
export interface Agency extends ContactEntity {
}
/**
 * 
 * @export
 * @interface Agent
 */
export interface Agent extends User {
    /**
     * 
     * @type {Agency}
     * @memberof Agent
     */
    agency?: Agency;
}
/**
 * 
 * @export
 * @interface Application
 */
export interface Application {
    /**
     * 
     * @type {string}
     * @memberof Application
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof Application
     */
    reference?: string;
    /**
     * 
     * @type {string}
     * @memberof Application
     */
    lastActiondate?: string;
    /**
     * 
     * @type {string}
     * @memberof Application
     */
    plannedDate?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Application
     */
    active?: boolean;
    /**
     * 
     * @type {number}
     * @memberof Application
     */
    version?: number;
    /**
     * 
     * @type {string}
     * @memberof Application
     */
    remarks?: string;
    /**
     * 
     * @type {string}
     * @memberof Application
     */
    createdDate?: string;
    /**
     * 
     * @type {string}
     * @memberof Application
     */
    appliedDate?: string;
    /**
     * 
     * @type {string}
     * @memberof Application
     */
    decisionDate?: string;
    /**
     * 
     * @type {SubsidyType}
     * @memberof Application
     */
    subsidyType?: SubsidyType;
    /**
     * 
     * @type {string}
     * @memberof Application
     */
    comment?: string;
    /**
     * 
     * @type {User}
     * @memberof Application
     */
    customer?: User;
    /**
     * 
     * @type {User}
     * @memberof Application
     */
    decisionMaker?: User;
    /**
     * 
     * @type {number}
     * @memberof Application
     */
    decisionBranchId?: number;
    /**
     * 
     * @type {Rpa}
     * @memberof Application
     */
    rpa?: Rpa;
    /**
     * 
     * @type {string}
     * @memberof Application
     */
    status?: string;
    /**
     * 
     * @type {number}
     * @memberof Application
     */
    amtApplied?: number;
    /**
     * 
     * @type {number}
     * @memberof Application
     */
    amtApproved?: number;
    /**
     * 
     * @type {number}
     * @memberof Application
     */
    estimatedDeposit?: number;
    /**
     * 
     * @type {number}
     * @memberof Application
     */
    actualDeposit?: number;
    /**
     * 
     * @type {number}
     * @memberof Application
     */
    amtRpa?: number;
    /**
     * 
     * @type {number}
     * @memberof Application
     */
    subsidyPercentage?: number;
    /**
     * 
     * @type {number}
     * @memberof Application
     */
    fundingSourceId?: number;
}
/**
 * 
 * @export
 * @interface Applications
 */
export interface Applications extends Paged {
    /**
     * 
     * @type {Array<Customer>}
     * @memberof Applications
     */
    items: Array<Customer>;
}
/**
 * 
 * @export
 * @interface Audited
 */
export interface Audited {
    /**
     * 
     * @type {string}
     * @memberof Audited
     */
    createdDate?: string;
    /**
     * 
     * @type {string}
     * @memberof Audited
     */
    createdBy?: string;
    /**
     * 
     * @type {string}
     * @memberof Audited
     */
    updatedDate?: string;
    /**
     * 
     * @type {string}
     * @memberof Audited
     */
    updatedBy?: string;
}
/**
 * 
 * @export
 * @interface Bank
 */
export interface Bank {
    /**
     * 
     * @type {string}
     * @memberof Bank
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof Bank
     */
    name?: string;
}
/**
 * 
 * @export
 * @interface BankAccount
 */
export interface BankAccount {
    /**
     * 
     * @type {Bank}
     * @memberof BankAccount
     */
    bank?: Bank;
    /**
     * 
     * @type {string}
     * @memberof BankAccount
     */
    number?: string;
    /**
     * 
     * @type {string}
     * @memberof BankAccount
     */
    name?: string;
}
/**
 * 
 * @export
 * @interface BasicEntity
 */
export interface BasicEntity {
    /**
     * 
     * @type {string}
     * @memberof BasicEntity
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof BasicEntity
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof BasicEntity
     */
    description?: string;
    /**
     * 
     * @type {boolean}
     * @memberof BasicEntity
     */
    active?: boolean;
}
/**
 * 
 * @export
 * @interface Card
 */
export interface Card {
    /**
     * 
     * @type {string}
     * @memberof Card
     */
    number?: string;
    /**
     * 
     * @type {string}
     * @memberof Card
     */
    expiryDate?: string;
    /**
     * 
     * @type {string}
     * @memberof Card
     */
    cvv2?: string;
}
/**
 * 
 * @export
 * @interface ContactEntity
 */
export interface ContactEntity extends Audited {
    /**
     * 
     * @type {string}
     * @memberof ContactEntity
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof ContactEntity
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof ContactEntity
     */
    description?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ContactEntity
     */
    active?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ContactEntity
     */
    phone?: string;
    /**
     * 
     * @type {string}
     * @memberof ContactEntity
     */
    url?: string;
    /**
     * 
     * @type {string}
     * @memberof ContactEntity
     */
    email?: string;
    /**
     * 
     * @type {string}
     * @memberof ContactEntity
     */
    address?: string;
    /**
     * 
     * @type {string}
     * @memberof ContactEntity
     */
    city?: string;
    /**
     * 
     * @type {string}
     * @memberof ContactEntity
     */
    postCode?: string;
    /**
     * 
     * @type {string}
     * @memberof ContactEntity
     */
    comments?: string;
}
/**
 * 
 * @export
 * @interface Countries
 */
export interface Countries {
    /**
     * 
     * @type {Array<Country>}
     * @memberof Countries
     */
    items: Array<Country>;
}
/**
 * 
 * @export
 * @interface Country
 */
export interface Country {
    /**
     * 
     * @type {number}
     * @memberof Country
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof Country
     */
    code?: string;
    /**
     * 
     * @type {string}
     * @memberof Country
     */
    name?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Country
     */
    active?: boolean;
}
/**
 * 
 * @export
 * @interface Credentials
 */
export interface Credentials {
    /**
     * User password
     * @type {string}
     * @memberof Credentials
     */
    password: string;
    /**
     * User identifier
     * @type {string}
     * @memberof Credentials
     */
    username: string;
}
/**
 * 
 * @export
 * @interface Customer
 */
export interface Customer extends User {
}
/**
 * 
 * @export
 * @interface Customers
 */
export interface Customers extends Paged {
    /**
     * 
     * @type {Array<Customer>}
     * @memberof Customers
     */
    items: Array<Customer>;
}
/**
 * 
 * @export
 * @interface FundingSource
 */
export interface FundingSource extends ContactEntity {
    /**
     * 
     * @type {string}
     * @memberof FundingSource
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof FundingSource
     */
    code?: string;
    /**
     * 
     * @type {string}
     * @memberof FundingSource
     */
    name?: string;
    /**
     * 
     * @type {number}
     * @memberof FundingSource
     */
    amt?: number;
    /**
     * 
     * @type {number}
     * @memberof FundingSource
     */
    subsidyTypeId?: number;
    /**
     * 
     * @type {number}
     * @memberof FundingSource
     */
    year?: number;
}
/**
 * 
 * @export
 * @interface Language
 */
export interface Language extends BasicEntity {
    /**
     * 
     * @type {boolean}
     * @memberof Language
     */
    selected?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Language
     */
    code?: string;
    /**
     * 
     * @type {string}
     * @memberof Language
     */
    flag?: string;
}
/**
 * 
 * @export
 * @interface Languages
 */
export interface Languages extends Paged {
    /**
     * 
     * @type {Array<Language>}
     * @memberof Languages
     */
    items: Array<Language>;
}
/**
 * 
 * @export
 * @interface Metric
 */
export interface Metric {
    /**
     * 
     * @type {string}
     * @memberof Metric
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof Metric
     */
    display?: string;
    /**
     * 
     * @type {number}
     * @memberof Metric
     */
    value?: number;
    /**
     * 
     * @type {string}
     * @memberof Metric
     */
    type?: string;
}
/**
 * 
 * @export
 * @interface Metrics
 */
export interface Metrics {
    /**
     * 
     * @type {Array<Metric>}
     * @memberof Metrics
     */
    items?: Array<Metric>;
}
/**
 * 
 * @export
 * @interface ModelError
 */
export interface ModelError {
    /**
     * 
     * @type {number}
     * @memberof ModelError
     */
    code: number;
    /**
     * 
     * @type {string}
     * @memberof ModelError
     */
    message: string;
}
/**
 * 
 * @export
 * @interface Paged
 */
export interface Paged {
    /**
     * 
     * @type {number}
     * @memberof Paged
     */
    page?: number;
    /**
     * 
     * @type {number}
     * @memberof Paged
     */
    pageSize?: number;
    /**
     * 
     * @type {number}
     * @memberof Paged
     */
    total?: number;
}
/**
 * 
 * @export
 * @interface Region
 */
export interface Region {
    /**
     * 
     * @type {number}
     * @memberof Region
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof Region
     */
    code?: string;
    /**
     * 
     * @type {string}
     * @memberof Region
     */
    name?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Region
     */
    active?: boolean;
    /**
     * 
     * @type {number}
     * @memberof Region
     */
    countryId?: number;
}
/**
 * 
 * @export
 * @interface Rpa
 */
export interface Rpa extends ContactEntity {
}
/**
 * 
 * @export
 * @interface SubsidyType
 */
export interface SubsidyType extends BasicEntity {
}
/**
 * 
 * @export
 * @interface SubsidyTypes
 */
export interface SubsidyTypes {
    /**
     * 
     * @type {Array<SubsidyType>}
     * @memberof SubsidyTypes
     */
    items: Array<SubsidyType>;
}
/**
 * 
 * @export
 * @interface Tags
 */
export interface Tags {
}
/**
 * 
 * @export
 * @interface Transaction
 */
export interface Transaction {
    /**
     * 
     * @type {string}
     * @memberof Transaction
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof Transaction
     */
    reference?: string;
    /**
     * 
     * @type {string}
     * @memberof Transaction
     */
    lastActiondate?: string;
    /**
     * 
     * @type {string}
     * @memberof Transaction
     */
    description?: string;
    /**
     * 
     * @type {string}
     * @memberof Transaction
     */
    remarks?: string;
    /**
     * 
     * @type {string}
     * @memberof Transaction
     */
    createdDate?: string;
    /**
     * 
     * @type {string}
     * @memberof Transaction
     */
    processDate?: string;
    /**
     * 
     * @type {string}
     * @memberof Transaction
     */
    comment?: string;
    /**
     * 
     * @type {string}
     * @memberof Transaction
     */
    type?: string;
    /**
     * 
     * @type {string}
     * @memberof Transaction
     */
    accountType?: string;
    /**
     * 
     * @type {Account}
     * @memberof Transaction
     */
    account?: Account;
    /**
     * 
     * @type {string}
     * @memberof Transaction
     */
    status?: string;
    /**
     * 
     * @type {number}
     * @memberof Transaction
     */
    amt?: number;
    /**
     * 
     * @type {string}
     * @memberof Transaction
     */
    currency?: string;
    /**
     * 
     * @type {number}
     * @memberof Transaction
     */
    fees?: number;
}
/**
 * 
 * @export
 * @interface Transactions
 */
export interface Transactions extends Paged {
    /**
     * 
     * @type {Array<Transaction>}
     * @memberof Transactions
     */
    items: Array<Transaction>;
}
/**
 * 
 * @export
 * @interface User
 */
export interface User extends Audited {
    /**
     * 
     * @type {string}
     * @memberof User
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    description?: string;
    /**
     * 
     * @type {boolean}
     * @memberof User
     */
    active?: boolean;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    phone?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    url?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    email?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    address?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    city?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    postCode?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    comments?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    firstName?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    lastName?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    username?: string;
    /**
     * 
     * @type {number}
     * @memberof User
     */
    identityTypeId?: number;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    identityNumber?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    role?: string;
    /**
     * 
     * @type {number}
     * @memberof User
     */
    languageId?: number;
    /**
     * 
     * @type {number}
     * @memberof User
     */
    regionId?: number;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    status?: string;
    /**
     * 
     * @type {number}
     * @memberof User
     */
    countryId?: number;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    language?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    token?: string;
}
/**
 * 
 * @export
 * @interface Users
 */
export interface Users extends Paged {
    /**
     * 
     * @type {Array<User>}
     * @memberof Users
     */
    items: Array<User>;
}
/**
 * 
 * @export
 * @interface Voucher
 */
export interface Voucher extends Account {
    /**
     * 
     * @type {string}
     * @memberof Voucher
     */
    pin?: string;
    /**
     * 
     * @type {Wallet}
     * @memberof Voucher
     */
    wallet?: Wallet;
    /**
     * 
     * @type {string}
     * @memberof Voucher
     */
    status?: string;
}
/**
 * 
 * @export
 * @interface Wallet
 */
export interface Wallet extends Account {
    /**
     * 
     * @type {string}
     * @memberof Wallet
     */
    pin?: string;
    /**
     * 
     * @type {string}
     * @memberof Wallet
     */
    status?: string;
}
/**
 * ApplicationApi - fetch parameter creator
 * @export
 */
export const ApplicationApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary new application reference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createApplication(options: any = {}): FetchArgs {
            const localVarPath = `/customer/application/new`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication monieBearerAuth required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary customer applications
         * @param {number} customerId customer id
         * @param {number} [page] Page index starting from 1
         * @param {number} [pageSize] Page size
         * @param {string} [q] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerApplications(customerId: number, page?: number, pageSize?: number, q?: string, options: any = {}): FetchArgs {
            // verify required parameter 'customerId' is not null or undefined
            if (customerId === null || customerId === undefined) {
                throw new RequiredError('customerId','Required parameter customerId was null or undefined when calling customerApplications.');
            }
            const localVarPath = `/customer/{customerId}/applications`
                .replace(`{${"customerId"}}`, encodeURIComponent(String(customerId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication monieBearerAuth required

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary application
         * @param {string} reference application reference parameter
         * @param {number} [pageSize] Page size
         * @param {string} [q] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApplication(reference: string, pageSize?: number, q?: string, options: any = {}): FetchArgs {
            // verify required parameter 'reference' is not null or undefined
            if (reference === null || reference === undefined) {
                throw new RequiredError('reference','Required parameter reference was null or undefined when calling getApplication.');
            }
            const localVarPath = `/application/{reference}`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication monieBearerAuth required

            if (reference !== undefined) {
                localVarQueryParameter['reference'] = reference;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary wallet
         * @param {string} reference wallet reference parameter
         * @param {number} [pageSize] Page size
         * @param {string} [q] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWallet(reference: string, pageSize?: number, q?: string, options: any = {}): FetchArgs {
            // verify required parameter 'reference' is not null or undefined
            if (reference === null || reference === undefined) {
                throw new RequiredError('reference','Required parameter reference was null or undefined when calling getWallet.');
            }
            const localVarPath = `/wallet/{reference}`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication monieBearerAuth required

            if (reference !== undefined) {
                localVarQueryParameter['reference'] = reference;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ApplicationApi - functional programming interface
 * @export
 */
export const ApplicationApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary new application reference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createApplication(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Application> {
            const localVarFetchArgs = ApplicationApiFetchParamCreator(configuration).createApplication(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary customer applications
         * @param {number} customerId customer id
         * @param {number} [page] Page index starting from 1
         * @param {number} [pageSize] Page size
         * @param {string} [q] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerApplications(customerId: number, page?: number, pageSize?: number, q?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Applications> {
            const localVarFetchArgs = ApplicationApiFetchParamCreator(configuration).customerApplications(customerId, page, pageSize, q, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary application
         * @param {string} reference application reference parameter
         * @param {number} [pageSize] Page size
         * @param {string} [q] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApplication(reference: string, pageSize?: number, q?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Application> {
            const localVarFetchArgs = ApplicationApiFetchParamCreator(configuration).getApplication(reference, pageSize, q, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary wallet
         * @param {string} reference wallet reference parameter
         * @param {number} [pageSize] Page size
         * @param {string} [q] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWallet(reference: string, pageSize?: number, q?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Wallet> {
            const localVarFetchArgs = ApplicationApiFetchParamCreator(configuration).getWallet(reference, pageSize, q, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ApplicationApi - factory interface
 * @export
 */
export const ApplicationApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary new application reference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createApplication(options?: any) {
            return ApplicationApiFp(configuration).createApplication(options)(fetch, basePath);
        },
        /**
         * 
         * @summary customer applications
         * @param {number} customerId customer id
         * @param {number} [page] Page index starting from 1
         * @param {number} [pageSize] Page size
         * @param {string} [q] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerApplications(customerId: number, page?: number, pageSize?: number, q?: string, options?: any) {
            return ApplicationApiFp(configuration).customerApplications(customerId, page, pageSize, q, options)(fetch, basePath);
        },
        /**
         * 
         * @summary application
         * @param {string} reference application reference parameter
         * @param {number} [pageSize] Page size
         * @param {string} [q] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApplication(reference: string, pageSize?: number, q?: string, options?: any) {
            return ApplicationApiFp(configuration).getApplication(reference, pageSize, q, options)(fetch, basePath);
        },
        /**
         * 
         * @summary wallet
         * @param {string} reference wallet reference parameter
         * @param {number} [pageSize] Page size
         * @param {string} [q] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWallet(reference: string, pageSize?: number, q?: string, options?: any) {
            return ApplicationApiFp(configuration).getWallet(reference, pageSize, q, options)(fetch, basePath);
        },
    };
};

/**
 * ApplicationApi - object-oriented interface
 * @export
 * @class ApplicationApi
 * @extends {BaseAPI}
 */
export class ApplicationApi extends BaseAPI {
    /**
     * 
     * @summary new application reference
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationApi
     */
    public createApplication(options?: any) {
        return ApplicationApiFp(this.configuration).createApplication(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary customer applications
     * @param {number} customerId customer id
     * @param {number} [page] Page index starting from 1
     * @param {number} [pageSize] Page size
     * @param {string} [q] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationApi
     */
    public customerApplications(customerId: number, page?: number, pageSize?: number, q?: string, options?: any) {
        return ApplicationApiFp(this.configuration).customerApplications(customerId, page, pageSize, q, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary application
     * @param {string} reference application reference parameter
     * @param {number} [pageSize] Page size
     * @param {string} [q] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationApi
     */
    public getApplication(reference: string, pageSize?: number, q?: string, options?: any) {
        return ApplicationApiFp(this.configuration).getApplication(reference, pageSize, q, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary wallet
     * @param {string} reference wallet reference parameter
     * @param {number} [pageSize] Page size
     * @param {string} [q] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationApi
     */
    public getWallet(reference: string, pageSize?: number, q?: string, options?: any) {
        return ApplicationApiFp(this.configuration).getWallet(reference, pageSize, q, options)(this.fetch, this.basePath);
    }

}
/**
 * AuthenticationCallsApi - fetch parameter creator
 * @export
 */
export const AuthenticationCallsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * user login
         * @summary API login
         * @param {Credentials} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login(body?: Credentials, options: any = {}): FetchArgs {
            const localVarPath = `/login`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication monieBearerAuth required

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Credentials" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthenticationCallsApi - functional programming interface
 * @export
 */
export const AuthenticationCallsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * user login
         * @summary API login
         * @param {Credentials} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login(body?: Credentials, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<User> {
            const localVarFetchArgs = AuthenticationCallsApiFetchParamCreator(configuration).login(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * AuthenticationCallsApi - factory interface
 * @export
 */
export const AuthenticationCallsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * user login
         * @summary API login
         * @param {Credentials} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login(body?: Credentials, options?: any) {
            return AuthenticationCallsApiFp(configuration).login(body, options)(fetch, basePath);
        },
    };
};

/**
 * AuthenticationCallsApi - object-oriented interface
 * @export
 * @class AuthenticationCallsApi
 * @extends {BaseAPI}
 */
export class AuthenticationCallsApi extends BaseAPI {
    /**
     * user login
     * @summary API login
     * @param {Credentials} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationCallsApi
     */
    public login(body?: Credentials, options?: any) {
        return AuthenticationCallsApiFp(this.configuration).login(body, options)(this.fetch, this.basePath);
    }

}
/**
 * CustomerApi - fetch parameter creator
 * @export
 */
export const CustomerApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary new application reference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createApplication(options: any = {}): FetchArgs {
            const localVarPath = `/customer/application/new`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication monieBearerAuth required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary customer applications
         * @param {number} customerId customer id
         * @param {number} [page] Page index starting from 1
         * @param {number} [pageSize] Page size
         * @param {string} [q] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerApplications(customerId: number, page?: number, pageSize?: number, q?: string, options: any = {}): FetchArgs {
            // verify required parameter 'customerId' is not null or undefined
            if (customerId === null || customerId === undefined) {
                throw new RequiredError('customerId','Required parameter customerId was null or undefined when calling customerApplications.');
            }
            const localVarPath = `/customer/{customerId}/applications`
                .replace(`{${"customerId"}}`, encodeURIComponent(String(customerId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication monieBearerAuth required

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary API cusotmer sign up
         * @param {Customer} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerSignUp(body?: Customer, options: any = {}): FetchArgs {
            const localVarPath = `/customer/signup`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication monieBearerAuth required

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Customer" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary customer transactions
         * @param {number} customerId customer id
         * @param {number} [page] Page index starting from 1
         * @param {number} [pageSize] Page size
         * @param {string} [q] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerTransactions(customerId: number, page?: number, pageSize?: number, q?: string, options: any = {}): FetchArgs {
            // verify required parameter 'customerId' is not null or undefined
            if (customerId === null || customerId === undefined) {
                throw new RequiredError('customerId','Required parameter customerId was null or undefined when calling customerTransactions.');
            }
            const localVarPath = `/customer/{customerId}/transactions`
                .replace(`{${"customerId"}}`, encodeURIComponent(String(customerId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication monieBearerAuth required

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary customer vouchers
         * @param {number} customerId customer id
         * @param {number} [page] Page index starting from 1
         * @param {number} [pageSize] Page size
         * @param {string} [q] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerVouchers(customerId: number, page?: number, pageSize?: number, q?: string, options: any = {}): FetchArgs {
            // verify required parameter 'customerId' is not null or undefined
            if (customerId === null || customerId === undefined) {
                throw new RequiredError('customerId','Required parameter customerId was null or undefined when calling customerVouchers.');
            }
            const localVarPath = `/customer/{customerId}/vouchers`
                .replace(`{${"customerId"}}`, encodeURIComponent(String(customerId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication monieBearerAuth required

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary customer voucher metrics
         * @param {number} customerId customer id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerVouchersMetrics(customerId: number, options: any = {}): FetchArgs {
            // verify required parameter 'customerId' is not null or undefined
            if (customerId === null || customerId === undefined) {
                throw new RequiredError('customerId','Required parameter customerId was null or undefined when calling customerVouchersMetrics.');
            }
            const localVarPath = `/customer/{customerId}/vouchers/metrics`
                .replace(`{${"customerId"}}`, encodeURIComponent(String(customerId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication monieBearerAuth required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary get customer wallet
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerWallet(options: any = {}): FetchArgs {
            const localVarPath = `/customer/wallet`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication monieBearerAuth required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CustomerApi - functional programming interface
 * @export
 */
export const CustomerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary new application reference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createApplication(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Application> {
            const localVarFetchArgs = CustomerApiFetchParamCreator(configuration).createApplication(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary customer applications
         * @param {number} customerId customer id
         * @param {number} [page] Page index starting from 1
         * @param {number} [pageSize] Page size
         * @param {string} [q] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerApplications(customerId: number, page?: number, pageSize?: number, q?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Applications> {
            const localVarFetchArgs = CustomerApiFetchParamCreator(configuration).customerApplications(customerId, page, pageSize, q, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary API cusotmer sign up
         * @param {Customer} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerSignUp(body?: Customer, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Customer> {
            const localVarFetchArgs = CustomerApiFetchParamCreator(configuration).customerSignUp(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary customer transactions
         * @param {number} customerId customer id
         * @param {number} [page] Page index starting from 1
         * @param {number} [pageSize] Page size
         * @param {string} [q] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerTransactions(customerId: number, page?: number, pageSize?: number, q?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Transactions> {
            const localVarFetchArgs = CustomerApiFetchParamCreator(configuration).customerTransactions(customerId, page, pageSize, q, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary customer vouchers
         * @param {number} customerId customer id
         * @param {number} [page] Page index starting from 1
         * @param {number} [pageSize] Page size
         * @param {string} [q] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerVouchers(customerId: number, page?: number, pageSize?: number, q?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Vouchers> {
            const localVarFetchArgs = CustomerApiFetchParamCreator(configuration).customerVouchers(customerId, page, pageSize, q, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary customer voucher metrics
         * @param {number} customerId customer id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerVouchersMetrics(customerId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Metrics> {
            const localVarFetchArgs = CustomerApiFetchParamCreator(configuration).customerVouchersMetrics(customerId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary get customer wallet
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerWallet(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Wallet> {
            const localVarFetchArgs = CustomerApiFetchParamCreator(configuration).customerWallet(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * CustomerApi - factory interface
 * @export
 */
export const CustomerApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary new application reference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createApplication(options?: any) {
            return CustomerApiFp(configuration).createApplication(options)(fetch, basePath);
        },
        /**
         * 
         * @summary customer applications
         * @param {number} customerId customer id
         * @param {number} [page] Page index starting from 1
         * @param {number} [pageSize] Page size
         * @param {string} [q] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerApplications(customerId: number, page?: number, pageSize?: number, q?: string, options?: any) {
            return CustomerApiFp(configuration).customerApplications(customerId, page, pageSize, q, options)(fetch, basePath);
        },
        /**
         * 
         * @summary API cusotmer sign up
         * @param {Customer} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerSignUp(body?: Customer, options?: any) {
            return CustomerApiFp(configuration).customerSignUp(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary customer transactions
         * @param {number} customerId customer id
         * @param {number} [page] Page index starting from 1
         * @param {number} [pageSize] Page size
         * @param {string} [q] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerTransactions(customerId: number, page?: number, pageSize?: number, q?: string, options?: any) {
            return CustomerApiFp(configuration).customerTransactions(customerId, page, pageSize, q, options)(fetch, basePath);
        },
        /**
         * 
         * @summary customer vouchers
         * @param {number} customerId customer id
         * @param {number} [page] Page index starting from 1
         * @param {number} [pageSize] Page size
         * @param {string} [q] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerVouchers(customerId: number, page?: number, pageSize?: number, q?: string, options?: any) {
            return CustomerApiFp(configuration).customerVouchers(customerId, page, pageSize, q, options)(fetch, basePath);
        },
        /**
         * 
         * @summary customer voucher metrics
         * @param {number} customerId customer id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerVouchersMetrics(customerId: number, options?: any) {
            return CustomerApiFp(configuration).customerVouchersMetrics(customerId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary get customer wallet
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerWallet(options?: any) {
            return CustomerApiFp(configuration).customerWallet(options)(fetch, basePath);
        },
    };
};

/**
 * CustomerApi - object-oriented interface
 * @export
 * @class CustomerApi
 * @extends {BaseAPI}
 */
export class CustomerApi extends BaseAPI {
    /**
     * 
     * @summary new application reference
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerApi
     */
    public createApplication(options?: any) {
        return CustomerApiFp(this.configuration).createApplication(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary customer applications
     * @param {number} customerId customer id
     * @param {number} [page] Page index starting from 1
     * @param {number} [pageSize] Page size
     * @param {string} [q] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerApi
     */
    public customerApplications(customerId: number, page?: number, pageSize?: number, q?: string, options?: any) {
        return CustomerApiFp(this.configuration).customerApplications(customerId, page, pageSize, q, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary API cusotmer sign up
     * @param {Customer} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerApi
     */
    public customerSignUp(body?: Customer, options?: any) {
        return CustomerApiFp(this.configuration).customerSignUp(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary customer transactions
     * @param {number} customerId customer id
     * @param {number} [page] Page index starting from 1
     * @param {number} [pageSize] Page size
     * @param {string} [q] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerApi
     */
    public customerTransactions(customerId: number, page?: number, pageSize?: number, q?: string, options?: any) {
        return CustomerApiFp(this.configuration).customerTransactions(customerId, page, pageSize, q, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary customer vouchers
     * @param {number} customerId customer id
     * @param {number} [page] Page index starting from 1
     * @param {number} [pageSize] Page size
     * @param {string} [q] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerApi
     */
    public customerVouchers(customerId: number, page?: number, pageSize?: number, q?: string, options?: any) {
        return CustomerApiFp(this.configuration).customerVouchers(customerId, page, pageSize, q, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary customer voucher metrics
     * @param {number} customerId customer id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerApi
     */
    public customerVouchersMetrics(customerId: number, options?: any) {
        return CustomerApiFp(this.configuration).customerVouchersMetrics(customerId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary get customer wallet
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerApi
     */
    public customerWallet(options?: any) {
        return CustomerApiFp(this.configuration).customerWallet(options)(this.fetch, this.basePath);
    }

}
/**
 * DefaultApi - fetch parameter creator
 * @export
 */
export const DefaultApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary new application reference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createApplication(options: any = {}): FetchArgs {
            const localVarPath = `/customer/application/new`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication monieBearerAuth required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary customer applications
         * @param {number} customerId customer id
         * @param {number} [page] Page index starting from 1
         * @param {number} [pageSize] Page size
         * @param {string} [q] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerApplications(customerId: number, page?: number, pageSize?: number, q?: string, options: any = {}): FetchArgs {
            // verify required parameter 'customerId' is not null or undefined
            if (customerId === null || customerId === undefined) {
                throw new RequiredError('customerId','Required parameter customerId was null or undefined when calling customerApplications.');
            }
            const localVarPath = `/customer/{customerId}/applications`
                .replace(`{${"customerId"}}`, encodeURIComponent(String(customerId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication monieBearerAuth required

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary API cusotmer sign up
         * @param {Customer} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerSignUp(body?: Customer, options: any = {}): FetchArgs {
            const localVarPath = `/customer/signup`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication monieBearerAuth required

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Customer" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary customer transactions
         * @param {number} customerId customer id
         * @param {number} [page] Page index starting from 1
         * @param {number} [pageSize] Page size
         * @param {string} [q] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerTransactions(customerId: number, page?: number, pageSize?: number, q?: string, options: any = {}): FetchArgs {
            // verify required parameter 'customerId' is not null or undefined
            if (customerId === null || customerId === undefined) {
                throw new RequiredError('customerId','Required parameter customerId was null or undefined when calling customerTransactions.');
            }
            const localVarPath = `/customer/{customerId}/transactions`
                .replace(`{${"customerId"}}`, encodeURIComponent(String(customerId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication monieBearerAuth required

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary customer vouchers
         * @param {number} customerId customer id
         * @param {number} [page] Page index starting from 1
         * @param {number} [pageSize] Page size
         * @param {string} [q] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerVouchers(customerId: number, page?: number, pageSize?: number, q?: string, options: any = {}): FetchArgs {
            // verify required parameter 'customerId' is not null or undefined
            if (customerId === null || customerId === undefined) {
                throw new RequiredError('customerId','Required parameter customerId was null or undefined when calling customerVouchers.');
            }
            const localVarPath = `/customer/{customerId}/vouchers`
                .replace(`{${"customerId"}}`, encodeURIComponent(String(customerId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication monieBearerAuth required

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary customer voucher metrics
         * @param {number} customerId customer id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerVouchersMetrics(customerId: number, options: any = {}): FetchArgs {
            // verify required parameter 'customerId' is not null or undefined
            if (customerId === null || customerId === undefined) {
                throw new RequiredError('customerId','Required parameter customerId was null or undefined when calling customerVouchersMetrics.');
            }
            const localVarPath = `/customer/{customerId}/vouchers/metrics`
                .replace(`{${"customerId"}}`, encodeURIComponent(String(customerId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication monieBearerAuth required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary get customer wallet
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerWallet(options: any = {}): FetchArgs {
            const localVarPath = `/customer/wallet`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication monieBearerAuth required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary application
         * @param {string} reference application reference parameter
         * @param {number} [pageSize] Page size
         * @param {string} [q] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApplication(reference: string, pageSize?: number, q?: string, options: any = {}): FetchArgs {
            // verify required parameter 'reference' is not null or undefined
            if (reference === null || reference === undefined) {
                throw new RequiredError('reference','Required parameter reference was null or undefined when calling getApplication.');
            }
            const localVarPath = `/application/{reference}`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication monieBearerAuth required

            if (reference !== undefined) {
                localVarQueryParameter['reference'] = reference;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary wallet
         * @param {string} reference wallet reference parameter
         * @param {number} [pageSize] Page size
         * @param {string} [q] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWallet(reference: string, pageSize?: number, q?: string, options: any = {}): FetchArgs {
            // verify required parameter 'reference' is not null or undefined
            if (reference === null || reference === undefined) {
                throw new RequiredError('reference','Required parameter reference was null or undefined when calling getWallet.');
            }
            const localVarPath = `/wallet/{reference}`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication monieBearerAuth required

            if (reference !== undefined) {
                localVarQueryParameter['reference'] = reference;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * user login
         * @summary API login
         * @param {Credentials} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login(body?: Credentials, options: any = {}): FetchArgs {
            const localVarPath = `/login`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication monieBearerAuth required

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Credentials" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary submit application
         * @param {Application} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitApplication(body?: Application, options: any = {}): FetchArgs {
            const localVarPath = `/customer/application/{reference}/submit`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication monieBearerAuth required

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Application" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary subsidy types
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        subsidyTypes(options: any = {}): FetchArgs {
            const localVarPath = `/subsidyTypes`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication monieBearerAuth required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DefaultApi - functional programming interface
 * @export
 */
export const DefaultApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary new application reference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createApplication(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Application> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).createApplication(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary customer applications
         * @param {number} customerId customer id
         * @param {number} [page] Page index starting from 1
         * @param {number} [pageSize] Page size
         * @param {string} [q] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerApplications(customerId: number, page?: number, pageSize?: number, q?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Applications> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).customerApplications(customerId, page, pageSize, q, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary API cusotmer sign up
         * @param {Customer} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerSignUp(body?: Customer, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Customer> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).customerSignUp(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary customer transactions
         * @param {number} customerId customer id
         * @param {number} [page] Page index starting from 1
         * @param {number} [pageSize] Page size
         * @param {string} [q] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerTransactions(customerId: number, page?: number, pageSize?: number, q?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Transactions> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).customerTransactions(customerId, page, pageSize, q, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary customer vouchers
         * @param {number} customerId customer id
         * @param {number} [page] Page index starting from 1
         * @param {number} [pageSize] Page size
         * @param {string} [q] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerVouchers(customerId: number, page?: number, pageSize?: number, q?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Vouchers> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).customerVouchers(customerId, page, pageSize, q, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary customer voucher metrics
         * @param {number} customerId customer id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerVouchersMetrics(customerId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Metrics> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).customerVouchersMetrics(customerId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary get customer wallet
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerWallet(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Wallet> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).customerWallet(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary application
         * @param {string} reference application reference parameter
         * @param {number} [pageSize] Page size
         * @param {string} [q] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApplication(reference: string, pageSize?: number, q?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Application> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).getApplication(reference, pageSize, q, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary wallet
         * @param {string} reference wallet reference parameter
         * @param {number} [pageSize] Page size
         * @param {string} [q] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWallet(reference: string, pageSize?: number, q?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Wallet> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).getWallet(reference, pageSize, q, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * user login
         * @summary API login
         * @param {Credentials} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login(body?: Credentials, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<User> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).login(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary submit application
         * @param {Application} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitApplication(body?: Application, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Application> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).submitApplication(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary subsidy types
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        subsidyTypes(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SubsidyTypes> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).subsidyTypes(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * DefaultApi - factory interface
 * @export
 */
export const DefaultApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary new application reference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createApplication(options?: any) {
            return DefaultApiFp(configuration).createApplication(options)(fetch, basePath);
        },
        /**
         * 
         * @summary customer applications
         * @param {number} customerId customer id
         * @param {number} [page] Page index starting from 1
         * @param {number} [pageSize] Page size
         * @param {string} [q] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerApplications(customerId: number, page?: number, pageSize?: number, q?: string, options?: any) {
            return DefaultApiFp(configuration).customerApplications(customerId, page, pageSize, q, options)(fetch, basePath);
        },
        /**
         * 
         * @summary API cusotmer sign up
         * @param {Customer} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerSignUp(body?: Customer, options?: any) {
            return DefaultApiFp(configuration).customerSignUp(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary customer transactions
         * @param {number} customerId customer id
         * @param {number} [page] Page index starting from 1
         * @param {number} [pageSize] Page size
         * @param {string} [q] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerTransactions(customerId: number, page?: number, pageSize?: number, q?: string, options?: any) {
            return DefaultApiFp(configuration).customerTransactions(customerId, page, pageSize, q, options)(fetch, basePath);
        },
        /**
         * 
         * @summary customer vouchers
         * @param {number} customerId customer id
         * @param {number} [page] Page index starting from 1
         * @param {number} [pageSize] Page size
         * @param {string} [q] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerVouchers(customerId: number, page?: number, pageSize?: number, q?: string, options?: any) {
            return DefaultApiFp(configuration).customerVouchers(customerId, page, pageSize, q, options)(fetch, basePath);
        },
        /**
         * 
         * @summary customer voucher metrics
         * @param {number} customerId customer id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerVouchersMetrics(customerId: number, options?: any) {
            return DefaultApiFp(configuration).customerVouchersMetrics(customerId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary get customer wallet
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerWallet(options?: any) {
            return DefaultApiFp(configuration).customerWallet(options)(fetch, basePath);
        },
        /**
         * 
         * @summary application
         * @param {string} reference application reference parameter
         * @param {number} [pageSize] Page size
         * @param {string} [q] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApplication(reference: string, pageSize?: number, q?: string, options?: any) {
            return DefaultApiFp(configuration).getApplication(reference, pageSize, q, options)(fetch, basePath);
        },
        /**
         * 
         * @summary wallet
         * @param {string} reference wallet reference parameter
         * @param {number} [pageSize] Page size
         * @param {string} [q] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWallet(reference: string, pageSize?: number, q?: string, options?: any) {
            return DefaultApiFp(configuration).getWallet(reference, pageSize, q, options)(fetch, basePath);
        },
        /**
         * user login
         * @summary API login
         * @param {Credentials} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login(body?: Credentials, options?: any) {
            return DefaultApiFp(configuration).login(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary submit application
         * @param {Application} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitApplication(body?: Application, options?: any) {
            return DefaultApiFp(configuration).submitApplication(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary subsidy types
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        subsidyTypes(options?: any) {
            return DefaultApiFp(configuration).subsidyTypes(options)(fetch, basePath);
        },
    };
};

/**
 * DefaultApi - object-oriented interface
 * @export
 * @class DefaultApi
 * @extends {BaseAPI}
 */
export class DefaultApi extends BaseAPI {
    /**
     * 
     * @summary new application reference
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public createApplication(options?: any) {
        return DefaultApiFp(this.configuration).createApplication(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary customer applications
     * @param {number} customerId customer id
     * @param {number} [page] Page index starting from 1
     * @param {number} [pageSize] Page size
     * @param {string} [q] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public customerApplications(customerId: number, page?: number, pageSize?: number, q?: string, options?: any) {
        return DefaultApiFp(this.configuration).customerApplications(customerId, page, pageSize, q, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary API cusotmer sign up
     * @param {Customer} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public customerSignUp(body?: Customer, options?: any) {
        return DefaultApiFp(this.configuration).customerSignUp(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary customer transactions
     * @param {number} customerId customer id
     * @param {number} [page] Page index starting from 1
     * @param {number} [pageSize] Page size
     * @param {string} [q] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public customerTransactions(customerId: number, page?: number, pageSize?: number, q?: string, options?: any) {
        return DefaultApiFp(this.configuration).customerTransactions(customerId, page, pageSize, q, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary customer vouchers
     * @param {number} customerId customer id
     * @param {number} [page] Page index starting from 1
     * @param {number} [pageSize] Page size
     * @param {string} [q] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public customerVouchers(customerId: number, page?: number, pageSize?: number, q?: string, options?: any) {
        return DefaultApiFp(this.configuration).customerVouchers(customerId, page, pageSize, q, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary customer voucher metrics
     * @param {number} customerId customer id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public customerVouchersMetrics(customerId: number, options?: any) {
        return DefaultApiFp(this.configuration).customerVouchersMetrics(customerId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary get customer wallet
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public customerWallet(options?: any) {
        return DefaultApiFp(this.configuration).customerWallet(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary application
     * @param {string} reference application reference parameter
     * @param {number} [pageSize] Page size
     * @param {string} [q] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getApplication(reference: string, pageSize?: number, q?: string, options?: any) {
        return DefaultApiFp(this.configuration).getApplication(reference, pageSize, q, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary wallet
     * @param {string} reference wallet reference parameter
     * @param {number} [pageSize] Page size
     * @param {string} [q] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getWallet(reference: string, pageSize?: number, q?: string, options?: any) {
        return DefaultApiFp(this.configuration).getWallet(reference, pageSize, q, options)(this.fetch, this.basePath);
    }

    /**
     * user login
     * @summary API login
     * @param {Credentials} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public login(body?: Credentials, options?: any) {
        return DefaultApiFp(this.configuration).login(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary submit application
     * @param {Application} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public submitApplication(body?: Application, options?: any) {
        return DefaultApiFp(this.configuration).submitApplication(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary subsidy types
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public subsidyTypes(options?: any) {
        return DefaultApiFp(this.configuration).subsidyTypes(options)(this.fetch, this.basePath);
    }

}
/**
 * SecurityApi - fetch parameter creator
 * @export
 */
export const SecurityApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary API cusotmer sign up
         * @param {Customer} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerSignUp(body?: Customer, options: any = {}): FetchArgs {
            const localVarPath = `/customer/signup`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication monieBearerAuth required

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Customer" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SecurityApi - functional programming interface
 * @export
 */
export const SecurityApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary API cusotmer sign up
         * @param {Customer} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerSignUp(body?: Customer, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Customer> {
            const localVarFetchArgs = SecurityApiFetchParamCreator(configuration).customerSignUp(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * SecurityApi - factory interface
 * @export
 */
export const SecurityApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary API cusotmer sign up
         * @param {Customer} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerSignUp(body?: Customer, options?: any) {
            return SecurityApiFp(configuration).customerSignUp(body, options)(fetch, basePath);
        },
    };
};

/**
 * SecurityApi - object-oriented interface
 * @export
 * @class SecurityApi
 * @extends {BaseAPI}
 */
export class SecurityApi extends BaseAPI {
    /**
     * 
     * @summary API cusotmer sign up
     * @param {Customer} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SecurityApi
     */
    public customerSignUp(body?: Customer, options?: any) {
        return SecurityApiFp(this.configuration).customerSignUp(body, options)(this.fetch, this.basePath);
    }

}
/**
 * TrasactionApi - fetch parameter creator
 * @export
 */
export const TrasactionApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary customer transactions
         * @param {number} customerId customer id
         * @param {number} [page] Page index starting from 1
         * @param {number} [pageSize] Page size
         * @param {string} [q] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerTransactions(customerId: number, page?: number, pageSize?: number, q?: string, options: any = {}): FetchArgs {
            // verify required parameter 'customerId' is not null or undefined
            if (customerId === null || customerId === undefined) {
                throw new RequiredError('customerId','Required parameter customerId was null or undefined when calling customerTransactions.');
            }
            const localVarPath = `/customer/{customerId}/transactions`
                .replace(`{${"customerId"}}`, encodeURIComponent(String(customerId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication monieBearerAuth required

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary customer vouchers
         * @param {number} customerId customer id
         * @param {number} [page] Page index starting from 1
         * @param {number} [pageSize] Page size
         * @param {string} [q] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerVouchers(customerId: number, page?: number, pageSize?: number, q?: string, options: any = {}): FetchArgs {
            // verify required parameter 'customerId' is not null or undefined
            if (customerId === null || customerId === undefined) {
                throw new RequiredError('customerId','Required parameter customerId was null or undefined when calling customerVouchers.');
            }
            const localVarPath = `/customer/{customerId}/vouchers`
                .replace(`{${"customerId"}}`, encodeURIComponent(String(customerId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication monieBearerAuth required

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary customer voucher metrics
         * @param {number} customerId customer id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerVouchersMetrics(customerId: number, options: any = {}): FetchArgs {
            // verify required parameter 'customerId' is not null or undefined
            if (customerId === null || customerId === undefined) {
                throw new RequiredError('customerId','Required parameter customerId was null or undefined when calling customerVouchersMetrics.');
            }
            const localVarPath = `/customer/{customerId}/vouchers/metrics`
                .replace(`{${"customerId"}}`, encodeURIComponent(String(customerId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication monieBearerAuth required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TrasactionApi - functional programming interface
 * @export
 */
export const TrasactionApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary customer transactions
         * @param {number} customerId customer id
         * @param {number} [page] Page index starting from 1
         * @param {number} [pageSize] Page size
         * @param {string} [q] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerTransactions(customerId: number, page?: number, pageSize?: number, q?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Transactions> {
            const localVarFetchArgs = TrasactionApiFetchParamCreator(configuration).customerTransactions(customerId, page, pageSize, q, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary customer vouchers
         * @param {number} customerId customer id
         * @param {number} [page] Page index starting from 1
         * @param {number} [pageSize] Page size
         * @param {string} [q] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerVouchers(customerId: number, page?: number, pageSize?: number, q?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Vouchers> {
            const localVarFetchArgs = TrasactionApiFetchParamCreator(configuration).customerVouchers(customerId, page, pageSize, q, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary customer voucher metrics
         * @param {number} customerId customer id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerVouchersMetrics(customerId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Metrics> {
            const localVarFetchArgs = TrasactionApiFetchParamCreator(configuration).customerVouchersMetrics(customerId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * TrasactionApi - factory interface
 * @export
 */
export const TrasactionApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary customer transactions
         * @param {number} customerId customer id
         * @param {number} [page] Page index starting from 1
         * @param {number} [pageSize] Page size
         * @param {string} [q] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerTransactions(customerId: number, page?: number, pageSize?: number, q?: string, options?: any) {
            return TrasactionApiFp(configuration).customerTransactions(customerId, page, pageSize, q, options)(fetch, basePath);
        },
        /**
         * 
         * @summary customer vouchers
         * @param {number} customerId customer id
         * @param {number} [page] Page index starting from 1
         * @param {number} [pageSize] Page size
         * @param {string} [q] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerVouchers(customerId: number, page?: number, pageSize?: number, q?: string, options?: any) {
            return TrasactionApiFp(configuration).customerVouchers(customerId, page, pageSize, q, options)(fetch, basePath);
        },
        /**
         * 
         * @summary customer voucher metrics
         * @param {number} customerId customer id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerVouchersMetrics(customerId: number, options?: any) {
            return TrasactionApiFp(configuration).customerVouchersMetrics(customerId, options)(fetch, basePath);
        },
    };
};

/**
 * TrasactionApi - object-oriented interface
 * @export
 * @class TrasactionApi
 * @extends {BaseAPI}
 */
export class TrasactionApi extends BaseAPI {
    /**
     * 
     * @summary customer transactions
     * @param {number} customerId customer id
     * @param {number} [page] Page index starting from 1
     * @param {number} [pageSize] Page size
     * @param {string} [q] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TrasactionApi
     */
    public customerTransactions(customerId: number, page?: number, pageSize?: number, q?: string, options?: any) {
        return TrasactionApiFp(this.configuration).customerTransactions(customerId, page, pageSize, q, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary customer vouchers
     * @param {number} customerId customer id
     * @param {number} [page] Page index starting from 1
     * @param {number} [pageSize] Page size
     * @param {string} [q] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TrasactionApi
     */
    public customerVouchers(customerId: number, page?: number, pageSize?: number, q?: string, options?: any) {
        return TrasactionApiFp(this.configuration).customerVouchers(customerId, page, pageSize, q, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary customer voucher metrics
     * @param {number} customerId customer id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TrasactionApi
     */
    public customerVouchersMetrics(customerId: number, options?: any) {
        return TrasactionApiFp(this.configuration).customerVouchersMetrics(customerId, options)(this.fetch, this.basePath);
    }

}
/**
 * WalletApi - fetch parameter creator
 * @export
 */
export const WalletApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary get customer wallet
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerWallet(options: any = {}): FetchArgs {
            const localVarPath = `/customer/wallet`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication monieBearerAuth required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WalletApi - functional programming interface
 * @export
 */
export const WalletApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary get customer wallet
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerWallet(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Wallet> {
            const localVarFetchArgs = WalletApiFetchParamCreator(configuration).customerWallet(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * WalletApi - factory interface
 * @export
 */
export const WalletApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary get customer wallet
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerWallet(options?: any) {
            return WalletApiFp(configuration).customerWallet(options)(fetch, basePath);
        },
    };
};

/**
 * WalletApi - object-oriented interface
 * @export
 * @class WalletApi
 * @extends {BaseAPI}
 */
export class WalletApi extends BaseAPI {
    /**
     * 
     * @summary get customer wallet
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletApi
     */
    public customerWallet(options?: any) {
        return WalletApiFp(this.configuration).customerWallet(options)(this.fetch, this.basePath);
    }

}
